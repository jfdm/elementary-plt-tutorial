\section{Type System}
\label{sec:type}

\begin{quote}
A means to know what we say is correct when saying things.
\end{quote}

Grammars helps us define \emph{what we say}, and semantics helps us define \emph{what we mean when we say}.
Type systems helps us define \emph{a means to know what we say is correct}.
Types are used to helps us take note of the \emph{kind} of objects that will exist when the program is executed.
These objects will represent the types in our type system.
The set of types in a type system is often represented as $T$.
For the \allang{} language from earlier there is only one type of object in play integers $\mathbb{Z}$.

\begin{bnf}
\bnfprod{$T_{Arith}$}{%
  \bnfts{$\mathbb{Z}$}
}
\end{bnf}

\noindent
When modelling types in \idris{} a data \texttt{Ty} type can be constructed.
The type object for the \allang{} is simply:

\begin{code}
data ArithTy = TyValue
\end{code}

If there were more object types, for example anonymous functions we would extend $T_{Arith}$ to include said types.
For example, if the \allang{} language had both boolean and function types: $T_{Arith}$ would be as follows:

\begin{bnf}
\bnfprod{$T_{ALT}$}{%
  \bnfts{$\mathbb{Z}$}
  \bnfor
  \bnfts{$\mathbb{B}$}
  \bnfor
  \bnfts{$T_{ALT}\rightarrow T_{ALT}$}
}
\end{bnf}

\noindent
Where $\mathbb{B}$ represents objects of type Boolean, and $T\rightarrow T$ object that are simple one argument functions.
The function type indicates a mapping from the type of the arugment to the type of the return value.

The object \texttt{ArithTy} will be extend as follows:

\begin{code}
data ArithTy = TyValue | TyBool | TyFunc ArithTy ArithTy
\end{code}

\noindent
Note how we can model in \idris{} types and grammars in similar ways.

The purpose of a type system is to allow for the type of an expression to be calculated from the expression itself.
Continuting with the \allang{}, for example, the expression $e=(1 + 2)$ will have type $\mathbb{Z}$ as the result of evaluating $e$ will be $3$ which is an integer.

Type systems are defined using relations that will allow for the pairing of expressions to types.
We call this relation \textsf{WellTyped}, and will contain only: \emph{correctly typed expresions paired with their type}.
Thus:
\[
((1+2), Int)\in\mathsf{WellTyped}\\
(\text{``Bob''},Int)\notin\mathsf{WellTyped}
\]

Taking our \idris{} translations \textsf{WellTyped} can be represented as a list of expression type pairs.

\begin{code}
welltyped : List (Arith, ArithTy)
welltyped = [(Addition (Value 1) (Value 2), TyValue)]
\end{code}

Note we do not have a means (yet) to ensure that only well-typed expressions are constructed.
These are typing rules and are introduced in Section~\ref{sec:rules}.
Before we can specify typing rules, we need to introduce the notion of \emph{Typing Environments.}

\subsection{Environments}
\label{sec:type:env}

For simple expressions a simple set of relations is sufficient.
However, in languages with variables such a simple relations is not sufficient.
Variables are mutable and the type of a variables will not be known prior to the use of the variable, and may change during program execution.
To address this issue we introduce the concept of a \emph{typing environment}, which is defined as a set that contains tuples of variables and their types: $(x,T)$
Type environments can be extended, and the addition of new variables to the environment may result in old definitions being removed.
Traditionally, type environments are denoted by the greek letter $\Gamma$.
A simple definition for a typing environment for the \allang{} language in \idris{} is a list of variable name type pairs.
For readability we first construct a generic type alias \texttt{Context expr ty}, that specifies the variable  (\texttt{var}) and its current type (\texttt{ty}) of the language being represented.

\begin{code}
Context : Type -> Type -> Type
Context var ty = List (var, ty)
\end{code}

\noindent
Using this alias we can then create typing environments of type \texttt{Context}.
For example type environments in the \allang{} can be modelled as

\begin{code}
example_context : Context String ArithTy
example_context = [("foo", TyValue), ("bar", TyValue)]
\end{code}

\paragraph{Note} Here we are purposefuly using a \emph{named representation} and keeping track of variables using their actual name.
This makes it easier to understand what is going on within contexts.
An alternate would be to use a \emph{nameless representation}, in our larger case study (Section~\ref{}) we will show how a nameless representation using \emph{de Bruijn} indices works.


\begin{center}\bfseries
add notion of context per expression
\end{center}

\subsection{Operating on Environments}
\label{sec:type:env-operations}

Before type environments can be used in anger we define several operations that operate on $\Gamma$.

\subsubsection{Removing}
\label{sec:type:env-operations:remove}

The first operation will update $\Gamma$ by removing all references to $x$.
\[
\Gamma\backslash x
\]
\noindent
This operation can be implemented as follows:
\begin{code}
remove : (a,b) -> Context a b -> Context a b
remove e es = deleteBy (\(x,y),(c,d) => x==c) e es
\end{code}

\subsubsection{Extending}
\label{sec:type:env-operations:extend}

The second operations is used to extend $\Gamma$ with a variable $x$ and will possible overide previous definitions.
\[
\Gamma,x:T = (\Gamma\backslash x)\cup\{x,T\}
\]
\noindent
Which can be representened as:
\begin{code}
extend : (a,b) -> Context a b -> Context a b
extend e es = e :: (remove e es)
\end{code}

\subsubsection{Searching}
\label{sec:type:env-operations:lookup}

For completness, the final operation defined is used to search the typying environment to extract the type for a specified variable.
\[
\mathsf{lookup}(\Gamma,x:T) = \text{??}
\]
\noindent
This can be implemented as:
\begin{code}
lookup : a -> Context a b -> Maybe b
lookup = List.lookup
\end{code}

\subsubsection{Improving \idris{} Implementation}
\label{sec:type:env-operations:classes}

We can enforce our formal models in \idris{} better by creating a type class that groups our implementations together as follows:
\begin{code}
class (Eq a, Eq b) => TypeEnv a b where
  remove : (a,b) -> Context a b -> Context a b
  extend : (a,b) -> Context a b -> Context a b
  lookup : a     -> Context a b -> Maybe b

  remove e es = deleteBy (\(x,y),(c,d) => x==c) e es
  extend e es = e :: (remove e es)
  lookup = List.lookup
\end{code}

\subsubsection{Example}
\label{sec:types:example}

Explaining changes to a typing environment is difficult to see with type systems that only have a single type.
We further motivate the need for typing environments by using the alternate type system $T_{ALT}$ introduced earlier.
Thus given the following type environment:
\[
\Gamma_{1}=\{(foo,\mathbb{Z}),(g,\mathbb{Z}\rightarrow\mathbb{Z})\}
\]

\begin{code}
env : Context String ArithTy'
env = [("foo", TyValue'), ("g", TyFunc' TyValue' TyValue')]
\end{code}

\noindent
$\Gamma_{1}$ can be updated as follows:
\[
\Gamma_{1},g:\mathbb{Z} =\{(foo,\mathbb{Z}),(g\mathbb{Z})\}
\]
\begin{code}
env' : TypeEnv String ArithTy' => Context String ArithTy'
env' = extend ("g", TyValue') env
\end{code}
\noindent
and:
\[
\Gamma_{1},f:(\mathbb{Z}\rightarrow\mathbb{Z})\rightarrow\mathbb{Z} =\{(foo,\mathbb{Z}),(g\mathbb{Z}),f:(\mathbb{Z}\rightarrow\mathbb{Z})\rightarrow\mathbb{Z}\}
\]
\begin{code}
env'' : TypeEnv String ArithTy' => Context String ArithTy'
env'' = extend ("f", TyFunc' (TyFunc' TyValue' TyValue') TyValue') env'
\end{code}

\subsection{Improving the definition of \textsf{WellTyped}.}
\label{sec:types:example}

Using this notion of a type environment we can improve our definition of $\mathsf{WellTyped}$ to include triples in the form of $(\Gamma,e,T)$.
The $\mathsf{WellTyped}$ set will contain expressions that have a type $T$ derived from a local context $\Gamma$.
\[
(\Gamma,e,T)\in\mathsf{WellTyped}
\]
\noindent
To save on typing the short hand $\Gamma\vdash e:T$ is used.

\begin{code}
WellTyped : Type
WellTyped = List (Context Arith ArithTy , Arith, ArithTy)
\end{code}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../tutorial.print"
%%% End:
