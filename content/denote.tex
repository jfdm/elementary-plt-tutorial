\section{Denotational Semantics}
\label{sec:denote}

\begin{center}\large\em
Using another base to say what we mean when we say something.
\end{center}

\noindent
So far we have introduced: how to model syntax, represent types, and enforce typing rules.
In this section we introduce the notion of \emph{Denotational Semantics} to provide an \emph{interpretation} of \allang{} to \idris{}.
Denotational semantics is a technique that allows us to define the semantics of a language's expressions using mathematics, usually set-theory.
However, maths while important can be boring, and I wouldn't know how to provide a denotational semantics for \allang{}\footnote{This is left as an exercise for the author\ldots}.
Instead  we will provide an interpretation of \allang{} in \idris{} such that we can build an interpreter that will allow us to interpret and execute \allang{} programs.
Here the notation $\interpB{e}$ will be used to denote the interpretation of an element in \allang{} to \idris{}.

An alternate definition of a language's semantics can be defined computationally using operational semantics\footnote{\textsc{Ibid}}.


\subsection{Types}
\label{sec:denote:types}

We begin by providing an interpretation of the types $T_{Arith}$:

\begin{center}
\begin{tabularx}{0.8\textwidth}{>{$}r<{$}>{\ttfamily}X}
\interpB{\mathbb{Z}}=& Int \\
\end{tabularx}
\end{center}

\noindent
A type interpreter can be written as follows:

\begin{code}
interpTy : ArithTy -> Type
interpTy TyValue = Int
\end{code}

\noindent
Simple, a little too simple methings\ldots.
Thus, we further motivate the interpretation of types using the alternate set of types $T_{ALT}$:

\begin{center}
\begin{tabularx}{0.8\textwidth}{>{$}r<{$}>{\ttfamily}X}
\interpB{\mathbb{Z}}=& Int \\
\interpB{\mathbb{B}}=& Bool \\
\interpB{T_{A}\rightarrow T_{B}}=& $\interpB{T_{A}}$ -> $\interpB{T_{B}}$ \\
\end{tabularx}
\end{center}

\noindent
Remember, types in \idris{} are first class values, and can be presented like any other values.
Yay for dependent types!
A type interpreter can be written as follows:

\begin{code}
interpTy : ArithTy -> Type
interpTy TyValue              = Int
interpTy TyBool               = Bool
interpTy (TyFunc argty retty) = interpTy argty -> interpTy retty
\end{code}

\subsection{Expressions}
\label{sec:denote:expressions}

Now we look to dealing with expressions.

\begin{center}
\begin{tabularx}{0.8\textwidth}{>{$}r<{$}>{\ttfamily}X}
\interpB{i}     =& i\\
\interpB{x}     =& ??\\
\interpB{-e}    =& (*) (-1) $\interpB{e}$\\
\interpB{x + y} =& (+) $\interpB{x}$ $\interpB{x}$ \\
\end{tabularx}
\end{center}

\noindent
Raw values are directly translated into \idris{} values with type \texttt{Int}.
Variables are\ldots
Negative numbers are interpreted expressions multiplied by $-1$.
Finally,  addition of two expressions is mapped to the \idris{} addition primitive \texttt{(+)}.
Our interpreter for \allang{} is contructed as follows:

\begin{code}
interp : Env ArithG -> Arith ArithG ArithTy -> interpTy ArithTy
interp env (Val x)        = x
interp env (Var name x)   = ?todo
interp env (Neg x)        = (*) (-1)           (interp env x)
interp env (Addition x y) = (+) (interp env x) (interp env y)
\end{code}

\noindent
Where:
\begin{code}
ArithG : Type
ArithG = Context Arith ArithTy
\end{code}


\subsection{Running}
\label{sec:denote:running}

\begin{center}
  \large\em Examples
\end{center}

\begin{center}
  \large\em How to run the interpreter.
\end{center}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../tutorial.print"
%%% End:
